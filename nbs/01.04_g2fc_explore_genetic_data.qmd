---
title: Retrieve Nucleotide Data
jupyter: python3
---

```{python}
# Merge this back into 01.03
```


> This notebook will likely be broken into at least two


```{python}
# #| default_exp dna
```

<!-- #| hide
from nbdev.showdoc import * -->

```{python}
# !cd ../ && pip install -e '.[dev]'
```

```{python}
import os

import numpy as np
import pandas as pd
pd.set_option('display.max_columns', None)

import plotly.express as px

import hilbertcurve
from hilbertcurve.hilbertcurve import HilbertCurve

    # !conda install openpyxl -y
    # ! conda install h5py -y
# ! pip install hilbertcurve

from EnvDL.core import *
from EnvDL.dna import *
```

```{python}
cache_path = '../nbs_artifacts/01.04_g2fc_explore_genetic_data/'
ensure_dir_path_exists(dir_path = cache_path)
```

## Access marker records

Here I'm adapting an approach I took in `dlgwas` for accessing panzea data to the G2F genotype data release. The table is too big to easily load in an manipulate in pandas so as a work around to easily access specific genomes, I split the table into a separate file for the header and each genome and renamed each so that these files can be read piecemeal. See the Readme below for more details.

```{python}
# #| export
# def read_txt(path, 
#              **kwargs # Intended to allow for explicit 'encoding' to be passed into open the file
#             ):
#     if 'encoding' in kwargs.keys():
#         print(kwargs)
#         with open(path, 'r', encoding  = kwargs['encoding']) as f:
#             data = f.read()        
#     else:    
#         with open(path, 'r') as f:
#             data = f.read()
            
#     return(data)
```

```{python}
# #| export

# def print_txt(path):
#     print(read_txt(path = path))
```

```{python}
geno_path = '../data/zma/g2fc/genotypes/'
```

This last point was completed with the following shell script.

```{python}
#
print_txt(path = geno_path+'split_and_rename.sh')
```

With that done, and with the summary files from tassel (position and taxa), the genomes can be individually loaded as needed.

```{python}
# Other than listing the taxa this isn't expected to be of much use for our purposes.
geno_taxa=pd.read_table(geno_path+'5_Genotype_Data_All_Years_Filter_TaxaSummary.txt')
geno_taxa.head()
```


```{python}
# Useful for converting between the physical location and site
geno_site = pd.read_table(geno_path+'5_Genotype_Data_All_Years_Filter_SiteSummary.txt'
                         ).rename(columns = {'Physical Position':'Position'})
geno_site.head()
```

Retrieving a genome by taxa name:

```{python}
# The genomes are in a folder with an identical name as their source table
table_directory = geno_path+'snps'
# Note however that the naming is altered to not use '/' in the pedigree
os.listdir(table_directory)[0:3]
```

```{python}
# #| export

# def taxa_to_filename(taxa = '05-397/250007467', delim = '/'): return(taxa.replace(delim, '__'))
```

```{python}
(taxa_to_filename(taxa = '05-397/250007467', delim = '/'),
 taxa_to_filename(taxa = '05-397:250007467', delim = ':'))
```

```{python}
# #| export

# def exists_geno(
#     taxa, # should be the desired taxa or a regex fragment (stopping before the __). E.g. 'B73' or 'B\d+'
#     **kwargs # optionally pass in a genome list (this allows for a different path or precomputing if we're finding a lot of genomes)
#              # optionally pass in a different path to the snp table folder
#     ):
#     if 'genome_files_path' not in kwargs.keys():
#         genome_files_path = '../data/zma/g2fc/genotypes/snps/'
#     else:
#         genome_files_path = kwargs['genome_files_path']
    
#     if 'genome_files' not in kwargs.keys():
#         import os
#         genome_files = os.listdir(genome_files_path)
#     else:
#         genome_files = kwargs['genome_files']
        
#     return(True in [True for e in genome_files if e == taxa])
```

```{python}
(exists_geno(taxa = 'W10004_0171__PHZ51'),
 exists_geno(taxa = 'not_real'))
```


```{python}
# #| export
# def find_geno(
#     taxa, # should be the desired taxa or a regex fragment (stopping before the __). E.g. 'B73' or 'B\d+'
#     **kwargs # optionally pass in a genome list (this allows for a different path or precomputing if we're finding a lot of genomes)
#              # optionally pass in a different path to the snp table folder
#     ):
#     "Search for existing marker sets __"
#     if 'genome_files_path' not in kwargs.keys():
#         genome_files_path = '../data/zma/g2fc/genotypes/snps/'
#     else:
#         genome_files_path = kwargs['genome_files_path']
    
#     if 'genome_files' not in kwargs.keys():
#         import os
#         genome_files = os.listdir(genome_files_path)
#     else:
#         genome_files = kwargs['genome_files']
#     import re
#     return( [e for e in genome_files if re.match(taxa+'__.+', e)] )
```

```{python}
find_geno(taxa = 'W10004_0171')
```

```{python}
# #| export

# def get_geno( 
#     taxa,
#     **kwargs 
#     ):
#     "Retrieve an existing marker set"
#     if 'genome_files_path' not in kwargs.keys():
#         genome_files_path = '../data/zma/g2fc/genotypes/snps/'
#     else:
#         genome_files_path = kwargs['genome_files_path']
        
#     with open(genome_files_path+taxa, 'r') as f:
#         data = f.read()    
#     data = data.split('\t')
#     return(data)
```

```{python}
get_geno('W10004_0171__PHZ51')[0:4]
```

In addition to returning a specific taxa, the table's headers can be retieved with "taxa".

```{python}
get_geno(taxa = 'Taxa')[0:4]
```

Converting between site and chromosome/position requires the `AGPv4_site` dataframe. A given record contains the taxa as well as the nucleotides, so with that entry excluded the chromosome / position can be paired up.

```{python}
len(get_geno(taxa = 'Taxa')), geno_site.shape
```


```{python}
ith_taxa = 'W10004_0171/PHZ51'
res = get_geno(taxa_to_filename(taxa = ith_taxa))   # Retrieve record
temp = geno_site.loc[:, ['Chromosome', 'Position']]  
temp[res[0]] = res[1:]                               # Add Col. with Nucleotides
temp.head()
```

## Look at SNP coverage

```{python}
mask = (temp.Chromosome == 1)

temp_pos = temp.loc[mask, ['Position']]
```

```{python}
temp_pos['Shift'] = 0
temp_pos.loc[1: , ['Shift']] = np.array(temp_pos.Position)[:-1]
temp_pos['Diff'] = temp_pos['Position'] - temp_pos['Shift']

temp_pos.loc[0, 'Diff'] = None
```

```{python}
temp_pos
```

```{python}
# px.histogram(temp_pos, x = 'Diff')
```

## Encode a marker sequence into ATCG

```{python}
res = get_geno(taxa_to_filename(taxa = 'W10004_0171/PHZ51')) 
res = res[1:] # drop taxa
```


```{python}
# #| export

# def list_to_ACGT(
#     in_seq, # This should be a list with strings corresponding to IUPAC codes e.g. ['A', 'C', 'Y']
#     progress = False
# ):
#     import numpy as np
#     import tqdm 
#     from tqdm import tqdm

#     # Convert IUPAC codes into pr ACGT -------------------------------------------
#     encode_dict = {
#         #     https://www.bioinformatics.org/sms/iupac.html
#         #     A     C     G     T
#         'A': [1,    0,    0,    0   ],
#         'C': [0,    1,    0,    0   ],
#         'G': [0,    0,    1,    0   ],
#         'T': [0,    0,    0,    1   ],
#         'K': [0,    0,    0.5,  0.5 ],
#         'M': [0.5,  0.5,  0,    0   ],
#         'N': [0.25, 0.25, 0.25, 0.25],
#         'R': [0.5,  0,    0.5,  0   ],
#         'S': [0,    0.5,  0.5,  0   ],
#         'W': [0.5,  0,    0,    0.5 ],
#         'Y': [0,    0.5,  0,    0.5 ],
#         #     Other values (assumed empty)
#         #     A     C     G     T
#          '': [0,    0,    0,    0   ],
#         '-': [0,    0,    0,    0   ],
#         '0': [0,    0,    0,    0   ],
#     }


#     # Cleanup -- 
#     # Any newlines need to be removed
#     in_seq = [e.replace('\n', '') for e in in_seq]

#     # Check if there's anything that should be in the dictionary but is not.
#     not_in_dict = [e for e in list(set(in_seq)) if e not in list(encode_dict.keys())]

#     if not_in_dict != []:
#         print("Waring: The following are not in the encoding dictionary and will be set as missing.\n"+str(not_in_dict))

#     in_seq = [e if e not in not_in_dict else '' for e in in_seq] 

#     # output matrix
#     GMat = np.zeros(shape = [len(in_seq), 4])

#     # convert all nucleotides to probabilities
#     if progress == True:
#         for nucleotide in tqdm(encode_dict.keys()):
#             mask = [True if e == nucleotide else False for e in  in_seq]
#             GMat[mask, :] = encode_dict[nucleotide]    
#     else:
#         for nucleotide in encode_dict.keys():
#             mask = [True if e == nucleotide else False for e in  in_seq]
#             GMat[mask, :] = encode_dict[nucleotide]

#     return(GMat)
```

```{python}
res = list_to_ACGT(in_seq = res)
res = res[0:1000]
```

## Hilbert Curve Transform

```{python}
res.shape
```





```{python}
# #| export

# def calc_needed_hilbert_p(n_needed = 1048576,
#                           max_p = 20):
#     out = None
#     for i in range(1, max_p):
#         if 4**i > n_needed:
#             out = i
#             break
#     return(out)
```





```{python}
# #| export

# def np_2d_to_hilbert(
#     in_seq # This should be a 2d numpy array with dimensions of [sequence, channels] 
# ):
#     import numpy as np
#     import tqdm
#     from tqdm import tqdm
    
#     import hilbertcurve
#     from hilbertcurve.hilbertcurve import HilbertCurve
    
#     import EnvDL
#     from EnvDL.dna import calc_needed_hilbert_p
    
#     n_snps = in_seq.shape[0]
#     n_channels = in_seq.shape[-1]
#     temp = in_seq

#     p_needed = calc_needed_hilbert_p(n_needed=n_snps)
    
#     # Data represented need not be continuous -- it need only have int positions
#     # a sequence or a sequence with gaps can be encoded
#     hilbert_curve = HilbertCurve(
#         p = p_needed, # iterations i.e. hold 4^p positions
#         n = 2    # dimensions
#         )

#     points = hilbert_curve.points_from_distances(range(n_snps))

#     dim_0 = np.max(np.array(points)[:, 0])+1 # add 1 to account for 0 indexing
#     dim_1 = np.max(np.array(points)[:, 1])+1
#     temp_mat = np.zeros(shape = [dim_0, dim_1, n_channels])
#     temp_mat[temp_mat == 0] = np.nan         #  empty values being used for visualization

#     for i in tqdm(range(n_snps)):
#         temp_mat[points[i][0], points[i][1], :] = temp[i]

#     return(temp_mat)
```

```{python}
# #| export
# def np_3d_to_hilbert(
#     in_seq # This should be a 3d numpy array with dimensions of [samples, sequence, channels] 
# ):
#     "This is the 3d version of `np_2d_to_hilbert`. The goal is to process all of the samples of an array in one go."
#     import numpy as np
#     import tqdm
#     from tqdm import tqdm
    
#     import hilbertcurve
#     from hilbertcurve.hilbertcurve import HilbertCurve

#     import EnvDL
#     from EnvDL.dna import calc_needed_hilbert_p
    
#     n_snps = in_seq.shape[1]
#     n_channels = in_seq.shape[-1]
#     temp = in_seq

#     p_needed = calc_needed_hilbert_p(n_needed=n_snps)
    
#     # Data represented need not be continuous -- it need only have int positions
#     # a sequence or a sequence with gaps can be encoded
#     hilbert_curve = HilbertCurve(
#         p = p_needed, # iterations i.e. hold 4^p positions
#         n = 2    # dimensions
#         )

#     points = hilbert_curve.points_from_distances(range(n_snps))

#     dim_0 = np.max(np.array(points)[:, 0])+1 # add 1 to account for 0 indexing
#     dim_1 = np.max(np.array(points)[:, 1])+1
#     temp_mat = np.zeros(shape = [in_seq.shape[0], dim_0, dim_1, n_channels])
#     temp_mat[temp_mat == 0] = np.nan         #  empty values being used for visualization

#     for i in tqdm(range(n_snps)):
#         temp_mat[:,                          # sample
#                  points[i][0], points[i][1], # x, y
#                  :] = temp[:, i]             # channels

#     return(temp_mat)
```

```{python}
demo = np_2d_to_hilbert(
    in_seq = np.asarray([np.linspace(1, 100, num= 50),
                         np.linspace(100, 1, num= 50)]).T
)
```

```{python}
px.imshow(demo[:,:,0])
```

```{python}
px.imshow(demo[:,:,1])
```


### Apply to subset of real marker data

Explictly convert a taxa

```{python}
taxa_to_filename(taxa = 'W10004_0171/PHZ51')
```

Or search for a taxa

```{python}
find_geno(taxa = 'W10004_0171')
```

Retrieve the sequence data

```{python}
res = get_geno(taxa_to_filename(taxa = 'W10004_0171/PHZ51')) 
res = res[1:] # drop taxa
res[0:10]
```

Convert from characters to encoded nucleotide probabilities

```{python}
res = list_to_ACGT(in_seq = res)
res = res[0:1000]
res
```

Convert the sequence to a hilbert curve

```{python}
# This will happen under the hood
# calc_needed_hilbert_p(n_needed=res.shape[0])
res_hilb = np_2d_to_hilbert(
    in_seq = res
)
```

```{python}
px.imshow( res[0:20, 0:1] )
```

```{python}
px.imshow( res_hilb[:, :, 0] )
```

```{python}
px.imshow( res_hilb[:, :, 1] )
```

```{python}
#| '0': h
#| '1': i
#| '2': d
#| '3': e
# import nbdev; nbdev.nbdev_export()
```



